{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main Page","text":"<p>V1.1 \u2013 APPROVED (23 January 2019)</p>"},{"location":"#introduction-background","title":"Introduction &amp; Background","text":"<p>It is important for all participants to understand and acknowledge that the architecture, especially the (database) components that will be delivered by TEMBO using AO, will by nature adhere to strictly enforced naming conventions and coding standards. Kindly review the graphic depiction https://www.i-nterprise.org/about.html of the intERPrise architecture carefully? This is a FOUNDATIONAL consideration.</p> <p>Fundamental to the intERPrise architecture, is the ABSOLUTE implementation and enforcement of true data centricity (https://datacentricmanifesto.org/principles/) at the lowest possible layer within the DB2 for i database.</p> <p>This means that ALL validations are enforced by way of *BEFORE triggers on the database and that entity relationships are enforced with the various available DB2 for i constraints. Secondary processing MAY be by way of *AFTER triggers, as optimal solution, where it makes sense.</p> <p>Additionally, all participants should note that ABSOLUTE separation between the database and the rest of the application will be enforced. Any integration will occur at the I/O Services layer and above, implementing the provided standardized \u201cError Handling\u201d processes. No deviation from this will be considered for inclusion in the standard public repository, unless formally adopted by the intERPrise standards committee.</p> <p>All of the intERPrise database components (metadata repository {aka data dictionary}, validation rules repository, tables {aka physical files}, logical layer {aka logical files, indexes, views}, constraints, triggers, IO Services and Enterprise Services \u2013 a genuine \u201cdata-centric\u201d, modern DB2 implementation that are \u201cself-aware\u201d and \u201cself-enforcing\u201d) are managed by AO in an integrated, cohesive manner. A copy of AO has been made available to the participating intERPrise developers \u2013 see Use of Adsero Optima.</p> <p>All the IBM i source and resulting objects can however be managed manually, using standard IBM i functionality, without requiring AO. AO simply manages and enforces this in a cohesive, comprehensive and holistic fashion.</p> <p>During the Synon 2E (S2E) \u201charvesting\u201c process all functional definitions are retrieved from the internal S2E files, and internal AO files are populated with relevant \u201charvested\u201d information. This is particularly important to acknowledge with regards to ANY validations found within the S2E models and action diagrams.</p> <p>All data validations found within the S2E models are stored in the AO Validation rules Repository.</p> <p>An additional consideration in all intERPrise provided components is how best to leverage ILE, RPG IV, DB2 for i and standard IBM i functionality (such as *MSGF, *USRSPC, *USRIDX, Pointers, subsystems, etc.), combined with developer productivity. This immediately place short data (aka internal) names on the agenda. Most heritage developers are intimately familiar with the naming conventions in use for the past 30+ (actually since the announcement of CPF and the System/38 in 1978) years and this naming scheme has served most well.</p> <p>Underlying this entire issue though, is the fact that IBM i enforces a 10 character HARD limit on ANY object name. See https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rbam6/rbam6objnamrules.htm for more detail, if in doubt. This despite all the changes around how source may be stored on the platform and perceptions that \u201clong, more descriptive\u201d program names and other objects names can be defined.</p> <p>It is vital that all participants acknowledge that the 10 character object name (QSYS.LIB file system) is fundamental to the intERPrise naming conventions, to keep everything simple, clear and concise.</p> <p>The \u201clong\u201d name perception developers and administrators may have is exactly that; a perception. The average IBM i developers and administrators in the SMB market can do without the complications of dealing with inconsistent naming between source and objects, especially in an environment where you may potentially deal with thousands of objects. This becomes particularly relevant in 24-hour production installations, where serious program malfunctions usually occur in the dead of night and immediate fixes are expected and demanded.</p>"},{"location":"#sections","title":"Sections","text":"<ol> <li>Target Audience<ul> <li>Consumers of intERPrise</li> <li>Contributing Developers to intERPrise</li> </ul> </li> <li>Source Repository and location of source files</li> <li>Supported Operating System Releases</li> <li>Supported programming languages</li> <li>Recommended IDE Release</li> <li>RDi Extension Names</li> <li>General IBM i naming conventions/principles applied</li> <li>Open Source tooling</li> <li>Use of special characters in source and object naming</li> <li>Use of FULLY FREE format RPG source</li> <li>Length of object and source member names</li> <li>Line length of source members</li> <li>Comments in Code</li> <li> Use and leveraging of standard IBM i objects and architecture</li> <li>Standardized Error Handling</li> <li>ABSOLUTE separation between the database and the rest of the application</li> <li>Function/Procedure \u2194 Modules \u2194 *SRVPGM</li> <li>Suggested maximum number of elements/components</li> <li>Use of Source code \u201cCopy Books\u201d</li> <li>Prototypes (External)</li> <li>Compiler Directives</li> <li>Use of libraries (schemas)</li> <li>Source Files</li> <li>\u201cDelivery\u201d channel or \u201cuser interface\u201d</li> <li>JSON standards</li> <li>Enhancing procedures/functions</li> <li>Definition of database layer components that will be delivered by AO</li> <li>Database components naming conventions</li> <li>Validation rules</li> <li>Use of surrogate keys in the database</li> <li>Central Metadata Repository (aka \u201cData Dictionary\u201d)</li> <li>RLA and SQL result set processing</li> <li>Standard Code templates</li> <li>MakeFile (or BUILD) Utility</li> <li>High Availability/Continuous Operations considerations</li> <li>Security Implementation</li> <li>Unacceptable coding constructs</li> <li>Documentation</li> <li>Use of Adsero Optima\u2122 (AO) by intERPrise participating developers</li> </ol>"},{"location":"#some-additional-background-on-naming-of-database-components","title":"Some additional background on naming of database components","text":"<ul> <li>https://www.itjungle.com/2008/02/06/fhg020608-story02/ - Don\u2019t Let SQL Name Your Baby</li> <li>https://www.itjungle.com/2008/03/05/fhg030508-story02/ - Don\u2019t Let SQL Name Your Baby, Take 2</li> <li>https://www.ibm.com/developerworks/data/library/techarticle/milligan/0108milligan.html - DB2 UDB for iSeries Long and Short Identifiers</li> <li>https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rbam6/rbam6objnamrules.htm - Object Naming Rules</li> </ul>"},{"location":"2-Sidebar/","title":"MediaWiki:Sidebar","text":"<p>Conventions &amp; Standards</p> <ul> <li>Target Audience</li> <li>Source Repository</li> <li>Supported OS Releases</li> <li>Supported programming languages</li> <li>Recommended IDE Release</li> <li>RDi Extension Names</li> <li>General naming conventions &amp; principles</li> <li>Open Source tooling</li> <li>Special characters</li> <li>FULLY FREE format RPG source</li> <li>Length of member names</li> <li>Line length of source members</li> <li>Comments in Code</li> <li>Standard IBM i objects and architecture</li> <li>Standardized Error Handling</li> <li>ABSOLUTE Separation between DB &amp; Application</li> <li>Function/Procedure \u2194 Modules \u2194 *SRVPGM</li> <li>Maximum elements/components</li> <li>Source code \u201cCopy Books\u201d</li> <li>Prototypes</li> <li>Compiler Directives</li> <li>Libraries (schemas)</li> <li>Source Files</li> <li>\u201cDelivery\u201d channel or \u201cuser interface\u201d</li> <li>JSON standards</li> <li>Enhancing procedures/functions</li> <li>Definition of AO database components</li> <li>Database components naming conventions</li> <li>Validation rules</li> <li>Use of surrogate keys</li> <li>Central Metadata Repository</li> <li>RLA and SQL result set processing</li> <li>Standard Code templates</li> <li>MakeFile Utility</li> <li>High Availability</li> <li>Security Implementation</li> <li>Unacceptable coding constructs</li> <li>Documentation</li> <li>Use of Adsero Optima\u2122 (AO)</li> </ul>"},{"location":"ABSOLUTE_separation_between_the_database_and_the_rest_of_the_application/","title":"ABSOLUTE separation between the database and the rest of the application","text":""},{"location":"ABSOLUTE_separation_between_the_database_and_the_rest_of_the_application/#absolute-separation-between-the-database-and-the-rest-of-the-application","title":"ABSOLUTE separation between the database and the rest of the application","text":"<p>Kindly review the architectural depiction at https://www.i-nterprise.org/about.html. From this, please acknowledge that integration and interfacing will occur at IO Services level.</p> <p>Absolutely no updates will be allowed against the database, from external tools or methods and such updates will be summarily rejected by DB2. Be cautioned of this fact.</p> <p>Read access external to the IO Services are possible due to the inherent capabilities of IBM i, but we would suggest that the IO Services should preferably be your ONLY connection/integration to the database.</p>"},{"location":"Central_Metadata_Repository/","title":"Central Metadata Repository","text":""},{"location":"Central_Metadata_Repository/#central-metadata-repository-aka-data-dictionary","title":"Central Metadata Repository (aka \u201cData Dictionary\u201d)","text":"<p>Fundamental to the data centric development paradigm, is a central metadata repository that contains all information describing and pertaining to any data element in the entire system; a single source of the truth.</p> <p>Any attribute of any data element, including all validation rules pertaining to that element, as well as detailed record where the element is used, is dynamically maintained and used by AO. This is the most critical base element of any system and is fundamental to a cohesive data quality and data integrity strategy, which is of paramount importance in today\u2019s world of cognitive processing.</p> <p>Any decision is only as good as the quality and relevance of the business rule underpinning that element. The entire premise underpinning data centricity and a central metadata repository is to manage and control DATA QUALITY and INTEGRITY (including no orphan records).</p>"},{"location":"Comments_in_Code/","title":"Comments in Code","text":""},{"location":"Comments_in_Code/#comments-in-code","title":"Comments in Code","text":"<p>It is important that a fine balance be established between too little or too many comments, with the objective to allow adopting developers to become familiar with the structure and logical code \u201cinsertion\u201d points as fast as possible.</p>"},{"location":"Compiler_Directives/","title":"Compiler Directives","text":""},{"location":"Compiler_Directives/#compiler-directives","title":"Compiler Directives","text":"<p>Due to the potential complexity and nuances possible by using compiler directives, this project will NOT use ANY custom compiler directives. All participating developers should consciously consider the bulk of the adopting developers. Details about the potential consumers can be found at Target Audience</p>"},{"location":"Database_components_naming_conventions/","title":"Database components naming conventions","text":""},{"location":"Database_components_naming_conventions/#database-components-naming-conventions","title":"Database components naming conventions","text":""},{"location":"Database_components_naming_conventions/#database-file-naming","title":"Database File Naming","text":"<p>The broad name \"FILE\" in this context is used to include the following;</p> <ul> <li>Physical Data Files<ul> <li>DDL Tables</li> <li>DDS Physical Files (unlikely to be used)</li> </ul> </li> <li>Logical Files<ul> <li>DDL Encoded Vector Index (EVI)</li> <li>DDL Binary Radix Index (BRI)</li> <li>DDL View</li> <li>DDS Logical View</li> <li>DDS Logical Join</li> <li>DDS Logical Non-Join (Multi/Format)</li> </ul> </li> </ul> <p>The naming standards and conventions described below apply to ALL of the above file types.</p>"},{"location":"Database_components_naming_conventions/#physical-name-structure","title":"Physical Name Structure","text":"<p><code>abbnnnF</code></p> <p>Where</p> <ul> <li><code>a</code> = Must be an acceptable IBM i naming start character.</li> <li><code>bb</code> = 2 alphanumeric characters. The abb characters together make up a data-set identification mnemonic that groups together files of common purpose. An example of this would be \"DEB\" as the Data-Set to use to group all \"Debtors\" related files (both Physical &amp; Logical) together.</li> <li><code>nnn</code> = These 3 characters are the alphanumeric characters (preferably numeric) which uniquely identify the file. They should also be used to sequence and group the files within the data-set into a logical, readable order. Using numerics allows for the sub-grouping by hundreds (10 sub-groups) and sequencing the files from 0 to 99 in the sub-group. It is always advisable to number in steps of 5 or 10 to allow for the insertion of new files in an appropriate place in the sequence.</li> <li><code>F</code> is the final letter, of the 7 making up the physical file name, signifying that the object is a DDS physical file or DDL table.</li> </ul> <p>There is a valid reason as to why the name of the physical file/table is restricted to 7 characters. This file is impacted by many of the other functions and components available in the DB2 database and this need to be named.</p> <p>By leaving 3 available characters after the file name, the other components can be named effectively by adding to the file name on which they are based. The naming standards for the other DB2 components will illustrate this in detail.</p>"},{"location":"Database_components_naming_conventions/#logical-name-structure","title":"Logical Name Structure","text":"<p><code>ffffffFx(x)</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the \"Primary\" or \"Only\" file upon which the logical is based.</li> <li><code>x(x)</code> = A to Z or 01 to 99 making 8-9 character names. The convention is to use 01 to 49 for \"join\" files, 50 - 99 for Multi-Format logicals and A to Z for \"non-join\" files. The choice of using 1 - 9 or 01 - 99 is based upon the maximum number of joins and multi-format logicals, where ffffffF is the MASTER in the join or multi-format.</li> </ul> <p>The justification for this form of naming is;</p> <ol> <li>It is easy to identify the primary file associated with a logical.</li> <li>When viewed in alphabetical sequence the logicals are listed following their common primary physical file.</li> <li>When restoring the database, the physical files are restored first, followed by the logicals allowing for a more efficient index build process.</li> </ol>"},{"location":"Database_components_naming_conventions/#trigger-program-naming","title":"Trigger Program Naming","text":"<p>Physical files have 7 events to which 1 or more trigger programs may be attached. These events are;</p> <ul> <li>BEFORE - *INSERT, *DELETE, *UDATE</li> <li>AFTER - *INSERT, *DELETE, *UDATE, *READ</li> </ul> <p>Also one trigger program may be attached to multiple events. All trigger programs will be written in RPGILE and will use the intERPrise Error Handling Services to communicate with the RDBMS</p> <p>Typically the *BEFORE trigger programs provide validation, provision of defaults and specialized calculations to be done before accepting the event. In the case of the *DELETE trigger the only validations which are appropriate are to check that the deletion is allowed. For example, a customer has no balance owing.</p> <p>The *AFTER trigger programs are used mainly to synchronize other files in the database when an event has been executed.</p> <p>The naming of trigger programs for all the events follows the same pattern;</p> <p><code>ffffffF_xn</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the physical file to which the trigger program will be attached.</li> <li><code>_x</code> = <code>_B</code> if the program is a *BEFORE trigger and <code>_A</code> if the program is an *AFTER trigger.</li> <li><code>n</code> = a sequence number from 0 to 9 for use when multiple *BEFORE/*AFTER trigger programs are required for the same file.</li> </ul> <p>When a trigger program is attached to a file event, that link is given a unique trigger name. The default for the ADDPFTRG command is *GEN which provides a system generated name. It is not advisable to allow this to happen as the names can sometimes be confusing and meaningless.</p> <p>The convention used in IRP for these event names is as follow;</p> <p><code>ffffffF_xyn</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the physical file to which the trigger program will be attached.</li> <li><code>_x</code> = <code>_B</code> if the program is a *BEFORE trigger and <code>_A</code> if the program is an *AFTER trigger.</li> <li><code>y</code> = <code>I</code> for Update, <code>U</code> for Update, <code>D</code> for Delete and <code>R</code> for Read.</li> <li><code>n</code> = <code>a</code> sequence number from 0 to 9 for use when multiple trigger programs are required for the same file and event.</li> </ul>"},{"location":"Database_components_naming_conventions/#io-services-naming","title":"I/O Services Naming","text":""},{"location":"Database_components_naming_conventions/#io-services-module","title":"I/O Services *MODULE","text":"<p>An I/O Services *MODULE is created, with few exceptions, for one, and only one, FILE, including Logicals, within the database. Generally speaking a module contains one exported pointer and one exported procedure. Other procedures usually exist to provide function for the I/O Service.</p> <p>The exported pointer is named filenameP, where filename is followed by \"P\". This is a system pointer which is pointing to the file record buffer defined in the services code.</p> <p>The exported procedure name (I/O Services Procedure) is filename@, file name followed by \"@\". This will be the name of the module after compilation as well as the procedure name called when the I/O Service functionality is required.</p>"},{"location":"Database_components_naming_conventions/#binder-source-member","title":"Binder Source Member","text":"<p>There is a binder source member for each Data-Set making up the database. It is named as xxxIOS@$ where xxx is the data-set mnemonic identifying the data-set.</p> <p>NOTE: Under no circumstances must the EXPORT statements within a binder source member be re-sequenced or removed. ANY procedure additions must be added at the END of the EXPORT list.</p>"},{"location":"Database_components_naming_conventions/#service-program-compiler","title":"Service Program Compiler","text":"<p>The service program compiler is a CLLE program containing a single statement which when executed will create the service program.</p> <p>This compiler is named for the data-set as xxxIOS@@ where xxx is the data-set mnemonic. The service program *SRVPGM created by this compiler will have the same name as the compiler, xxxIOS@@.</p>"},{"location":"Definition_of_database_layer_components_that_will_be_delivered_by_AO/","title":"Definition of database layer components that will be delivered by AO","text":""},{"location":"Definition_of_database_layer_components_that_will_be_delivered_by_AO/#definition-of-database-layer-components-that-will-be-delivered-by-ao","title":"Definition of database layer components that will be delivered by AO","text":"<p>AO will provide and maintain the entire database layer, which includes a metadata repository {aka data dictionary}, validation rules repository, tables {aka physical files}, logical layer {aka logical files, indexes, views}, constraints, triggers, IO Services and Enterprise Services \u2013 a genuine \u201cdata-centric\u201d, modern DB2 implementation that is \u201cself-aware\u201d and \u201cself-enforcing\u201d.</p> <p>Kindly review the published architecture at https://www.i-nterprise.org/about.html</p> <p>No naming of ANY database component will be left to the operating system. ALL components will be named and managed by the Committee, using AO.</p>"},{"location":"Delivery_channel_or_user_interface/","title":"Delivery channel or user interface","text":""},{"location":"Delivery_channel_or_user_interface/#delivery-channel-or-user-interface","title":"\u201cDelivery\u201d channel or \u201cuser interface\u201d","text":"<p>Until the first GA release is available, all our efforts will be invested to deliver the iWebSrv interface as the initial standard interface. Once that is functional and leading edge, the committee will then consider other interface requests as well.</p>"},{"location":"Documentation/","title":"Documentation","text":""},{"location":"Documentation/#documentation","title":"Documentation","text":"<p>All technical code based documentation of intERPrise will be provided by ILEDocs kindly made available by Mihael Schultz.</p> <p>All User Documentation will be published within the Wiki, once all functionality has been delivered.</p>"},{"location":"Enhancing_procedures_functions/","title":"Enhancing procedures functions","text":""},{"location":"Enhancing_procedures_functions/#enhancing-proceduresfunctions","title":"Enhancing procedures/functions","text":"<p>All provided procedures/functions will implement the same approach IBM has followed on IBM i API\u2019s, where additional or enhanced functionality (where parameter changes are required) will be implemented with new optional parameter sets at the end of the parameter list, to prevent \u201cbreaking\u201d existing functions.</p> <p>Kindly see \u201cIBM i: Programming API overview and concepts\u201d for more details.</p>"},{"location":"Function_Procedure_Modules_SRVPGM/","title":"Function Procedure Modules SRVPGM","text":""},{"location":"Function_Procedure_Modules_SRVPGM/#functionprocedure-modules-srvpgm","title":"Function/Procedure \u2194 Modules \u2194 *SRVPGM","text":"<p>It is CRITICAL that the inherent capabilities of ILE be fully exploited and leveraged. As little code duplication and single instance re-usable code components are the objective we strive for. This should be a continuous focus of every participating developer.</p> <p>The moment there is a possibility that a specific function/procedure may be required or potentially valuable to other functions, it should immediately be made available as a module in a service program.</p> <p>If uncertain about this, please review the materials at https://www.ile-rpg.org/education.html again.</p>"},{"location":"Function_Procedure_Modules_SRVPGM/#proceduresfunctions","title":"Procedures/Functions","text":"<p>As procedures are the basic building blocks everything is built upon they should get extra attention when being developed. Consciously consider the principle of single-instance re-usable code, with as little as practically possible duplication. Consider future maintainability at all times, keeping the functions/procedures tight and concise.</p> <p>It is important to recognise that there is a fine balance between limiting duplication, versus providing overly complicated code. As a result, if overly complex code and \u201coverloading\u201d of an existing function becomes a future maintenance concern, rather create a new function/procedure, indicating the duplication/overlap.</p> <p>If substantial duplication between two or more procedures/functions exists, rather create a separate function/procedure with the common code within the same module. The objective should always be to limit duplication as far as practically possible.</p>"},{"location":"Function_Procedure_Modules_SRVPGM/#modules","title":"Modules","text":"<p>Modules are the basic building block of any program and/or service program. The size of a module varies greatly but should be kept as short and concise as practical. Consciously consider the maintainability of the code produced.</p> <p>As described in the preceding paragraph describing functions/procedures, always strive to limit duplication, by \u201cwrapping\u201d common code in separate functions/procedures within the module.</p> <p>The following principles should be followed:</p> <ul> <li>One module should only cover one domain.</li> <li>One module should preferably have multiple procedures.</li> <li>Each procedure in a module should have a prototype definition copybook.</li> </ul>"},{"location":"Function_Procedure_Modules_SRVPGM/#service-programs","title":"Service programs","text":"<p>A service program may preferably contain multiple modules. Additionally service programs should be function bound, grouping all related activity together.</p>"},{"location":"General_IBM_i_naming_conventions_principles_applied/","title":"General IBM i naming conventions principles applied","text":""},{"location":"General_IBM_i_naming_conventions_principles_applied/#general-ibm-i-naming-conventions-principles-applied","title":"General IBM i naming conventions principles applied","text":"<p>The adopted naming scheme is heavily influenced by more than 35 years\u2019 experience developing commercial applications for the object based operating system known today as IBM i. Our choices are deliberate, in order to facilitate extracting maximum value from inherent operating system capabilities. Our chosen naming scheme adheres and implements the same constructs used within IBM i.</p> <p>We need to formally acknowledge the significant contribution the Synon 2E (today known as CA 2E) approach made to formalize and document some of our fundamental deliberations.</p> <p>The following considerations influenced the official naming scheme significantly:</p> <ul> <li>It should be applicable to entities at all levels. IBM i entities include all IBM i object types/attributes, files, formats, fields, and members.</li> <li>The naming of components should be rule-based. It should be possible to generate a new name or to analyze an old one by a rule, rather than by referring to a table or other central reference.</li> <li>The rules should be based on relevant categories of distinction; for instance, properties of the entities being named that are important in distinguishing them from other entities of the same type. We will distinguish between database files by both the file type (physical {table}/logical {view/index/LF/Join}) and the nature of the file\u2019s contents; and distinguish between programs by their function.</li> <li>Allow the names generated by the convention to lend them to generic manipulation. This means adopting names that give useful left to right generic names for manipulation by CL commands.</li> <li>Name objects that perform a function (commands and programs) according to the action they perform upon an object or entity; use the form \u2018verb + object\u2019. For objects that have actions performed upon them (as files, user spaces, users indexes, message queues), base their names on the significant entity that they represent; use the form \u2018object\u2019 or \u2018adjective + object\u2019. For example, Work with Active Jobs (WRKACTJOB), Date format system value (QDATFMT), communications subsystem (QCMN).</li> <li>Encode as much useful information as possible within the names it generates about the role of the entity, and its relation to other entities.</li> <li>Be easy to remember. Simplicity, consistency, and adherence to natural language principles will facilitate this.</li> <li>Use the same name for an entity wherever it is used.</li> <li>Use IBM i mnemonics wherever possible.</li> <li>Follow an object-action system.</li> <li>Be as compatible as possible with other standards, notably those inherent in the IBM i shipped system. For example, no object name should begin with the letter \u2018Q\u2019, which is reserved for IBM-supplied objects.</li> </ul> <p>There are two separate interfaces in the IBM i architecture on which we focused:</p> <ul> <li>The Control Language</li> <li>The DDS and DDL specifications/language</li> </ul> <p>It is possible that the \u201cdelivery channel\u201d or \u201cclient\u201d naming convention will differ from the database layer, due to language differences and the tooling being used.</p> <p>As the tools and technologies for providing \u201cdelivery channels\u201d are incorporated into intERPrise, those standards and conventions will be published for that environment as soon as it is adopted. The committee is desirous and committed that intERPrise should adopt all the mainstream and leading edge interface mechanisms that will provide value to the installed base.</p> <p>The committee however does not foresee any display file (5250 DSPF) based solutions and strongly advises against it. However, the SMB installed base will dictate if they see any need for a DSPF based solution in an event driven paradigm.</p> <p>All IBM i native components however have to conform to the published IBM i naming scheme.</p>"},{"location":"High_Availability/","title":"High Availability","text":""},{"location":"High_Availability/#high-availabilitycontinuous-operations-considerations","title":"High Availability/Continuous Operations considerations","text":"<p>We are working with HA vendors to ensure that intERPrise are fully HA aware and ready. The HA convenstions and standards will be updated once fully implemented.</p>"},{"location":"JSON_standards/","title":"JSON standards","text":""},{"location":"JSON_standards/#json-standards","title":"JSON Standards","text":"<p>The JSON \u201cpayloads\u201d are constructed to leverage the inherent capability of the iWebSrv product. Once this is stable, the committee will publish these standards, which will serve as basis for other similar offerings.</p>"},{"location":"Length_of_object_and_source_member_names/","title":"Length of object and source member names","text":""},{"location":"Length_of_object_and_source_member_names/#length-of-object-and-source-member-names","title":"Length of object and source member names","text":"<p>ALL IBM i component (source and objects) names will be strictly limited to 10 characters maximum, subject to the published naming conventions.</p>"},{"location":"Line_length_of_source_members/","title":"Line length of source members","text":""},{"location":"Line_length_of_source_members/#line-length-of-source-members","title":"Line length of source members","text":"<p>Due to the inherent capabilities of the new generation IDE\u2019s, we have adopted 150 characters as the current standard length of all intERPrise source files. It is not optimal for earlier tools (ADTS), but we are doing our best to find a way to accommodate both developer audiences.</p>"},{"location":"MakeFile_Utility/","title":"MakeFile Utility","text":""},{"location":"MakeFile_Utility/#makefile-or-build-utility","title":"MakeFile (or BUILD) Utility","text":"<p>As the sequence of building the database are of critical importance, AO have open sourced part of their product, to build all the required database components in the correct sequence.</p>"},{"location":"NSC-Database_File_Naming/","title":"NSC:Database File Naming","text":"<p>The broad name \"FILE\" in this context is used to include the following;</p> <ul> <li>Physical Data Files<ul> <li>DDL Tables</li> <li>DDS Physical Files (unlikely to be used)</li> </ul> </li> <li>Logical Files<ul> <li>DDL Encoded Vector Index (EVI)</li> <li>DDL Binary Radix Index (BRI)</li> <li>DDL View</li> <li>DDS Logical View</li> <li>DDS Logical Join</li> <li>DDS Logical Non-Join (Multi/Format)</li> </ul> </li> </ul> <p>The naming standards and conventions described below apply to ALL of the above file types.</p>"},{"location":"NSC-Database_File_Naming/#physical-name-structure","title":"Physical Name Structure","text":"<p><code>abbnnnF</code></p> <p>Where</p> <ul> <li><code>a</code> = Must be an acceptable IBM i naming start character.</li> <li><code>bb</code> = 2 alphanumeric characters.<ul> <li>The abb characters together make up a data-set identification mnemonic that groups together files of common purpose. An example of this would be \"DEB\" as the Data-Set to use to group all \"Debtors\" related files (both Physical &amp; Logical) together.</li> </ul> </li> <li><code>nnn</code> = These 3 characters are the alphanumeric characters (preferably numeric) which uniquely identify the file.<ul> <li>They should also be used to sequence and group the files within the data-set into a logical, readable order. Using numerics allows for the sub-grouping by hundreds (10 sub-groups) and sequencing the files from 0 to 99 in the sub-group. It is always advisable to number in steps of 5 or 10 to allow for the insertion of new files in an appropriate place in the sequence.</li> </ul> </li> <li><code>F</code> is the final letter, of the 7 making up the physical file name, signifying that the object is a DDS physical file or DDL table.</li> </ul> <p>There is a valid reason as to why the name of the physical file/table is restricted to 7 characters. This file is impacted by many of the other functions and components available in the DB2 database and these need to be named. By leaving 3 available characters after the file name, the other components can be named effectively by adding to the file name on which they are based. The naming standards for the other DB2 components will illustrate this in detail.</p>"},{"location":"NSC-Database_File_Naming/#logical-name-structure","title":"Logical Name Structure","text":"<p><code>ffffffFx</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the \"Primary\" or \"Only\" file upon which the logical is based.</li> <li><code>x</code> = A to Z or 0 to 9 making 8 character names. The convention is to use 0 to 9 for \"join\" files and A to Z for \"non-join\" files.</li> </ul> <p>The justification for this form of naming is;</p> <ol> <li>It is easy to identify the primary file associated with a logical.</li> <li>When viewed in alphabetical sequence the logicals are listed following their common primary physical file.</li> <li>When restoring the database, the physical files are restored first, followed by the logicals allowing for a more efficient index build process.</li> </ol>"},{"location":"NSC-I_O_Services_Naming/","title":"NSC:I/O Services Naming","text":""},{"location":"NSC-I_O_Services_Naming/#io-server-module","title":"I/O Server *MODULE","text":"<p>An I/O Server *MODULE is created, with few exceptions, for one, and only one, FILE, including Logicals, within the database. Generally speaking a module contains one exported pointer and one exported procedure. Other procedures usually exist to provide function for the I/O Server.</p> <p>The exported pointer is named <code>filenameP</code>, where filename is followed by \"P\". This is a system pointer which is pointing to the file record buffer defined in the server code.</p> <p>The exported procedure name (I/O Server Procedure) is <code>filename@</code>, file name followed by \"@\". This will be the name of the module after compilation as well as the procedure name called when the I/O Server functionality is required.</p>"},{"location":"NSC-I_O_Services_Naming/#binder-source-member","title":"Binder Source Member","text":"<p>There is a binder source member for each Data-Set making up the database. It is named as <code>xxxIOS$$</code> where <code>xxx</code> is the data-set mnemonic identifying the data-set.</p>"},{"location":"NSC-I_O_Services_Naming/#service-program-compiler","title":"Service Program Compiler","text":"<p>The service program compiler is a CLLE program containing a single statement which when executed will create the service program.</p> <p>This compiler is named for the data-set as <code>xxxIOS@@</code> where <code>xxx</code> is the data-set mnemonic. The service program *SRVPGM created by this compiler will have the same name as the compiler, <code>xxxIOS@@</code>.</p>"},{"location":"NSC-Trigger_Program_Naming/","title":"NSC:Trigger Program Naming","text":"<p>Physical files have 7 events to which 1 or more trigger programs may be attached. These events are;</p> <ul> <li>BEFORE - *INSERT, *DELETE, *UDATE</li> <li>AFTER - *INSERT, *DELETE, *UDATE, *READ</li> </ul> <p>Also one trigger program may be attached to multiple events.</p> <p>All trigger programs will be written in RPGILE and will use the Error Handling Services to communicate with the RDBMS</p> <p>Typically the *BEFORE trigger programs provide validation, provision of defaults and specialized calculations to be done before accepting the event. In the case of the *DELETE trigger the only validations which are appropriate are to check that the deletion is allowed. For example, a customer has no balance owing.</p> <p>The *AFTER trigger programs are used mainly to synchronize other files in the database when an event has been executed.</p> <p>The naming of trigger programs for all the events follows the same pattern;</p> <p><code>ffffffF_xn</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the physical file to which the trigger program will be attached.</li> <li><code>_x</code> = <code>_B</code> if the program is a *BEFORE trigger and <code>_A</code> if the program is an *AFTER trigger.</li> <li><code>n</code> = a sequence number from 0 to 9 for use when multiple *BEFORE/*AFTER trigger programs are required for the same file.</li> </ul> <p>When a trigger program is attached to a file event, that link is given a unique trigger name. The default for the ADDPFTRG command is *GEN which provides a system generated name. It is not advisable to allow this to happen as the names can sometimes be confusing and meaningless.</p> <p>The convention used in IRP for these event names is as follow;</p> <p><code>ffffffF_xyn</code></p> <p>Where</p> <ul> <li><code>ffffffF</code> is the name of the physical file to which the trigger program will be attached.</li> <li><code>_x</code> = <code>_B</code> if the program is a *BEFORE trigger and <code>_A</code> if the program is an *AFTER trigger.</li> <li><code>y</code> = I for Update, U for Update, D for Delete and R for Read.</li> <li><code>n</code> = a sequence number from 0 to 9 for use when multiple trigger programs are required for the same file and event.</li> </ul>"},{"location":"Open_Source_tooling/","title":"Open Source tooling","text":""},{"location":"Open_Source_tooling/#open-source-tooling","title":"Open Source tooling","text":"<ul> <li>OpenAPI Specification \u2013 all JSON will be managed using the tools available at the https://swagger.io/ site</li> <li>GitHub</li> <li>JSONLint</li> <li>ValidateJavaScript</li> <li>ILEDocs</li> </ul> <p>This list will be augmented and refined as this initiative matures.</p>"},{"location":"Prototypes_External/","title":"Prototypes (External)","text":""},{"location":"Prototypes_External/#prototypes-external","title":"Prototypes (External)","text":"<p>Kindly review the provided prototype copybook and code using the procedure prototype for the best explanation and example.</p> <p>See Calling Programs and Procedures in ILE RPG Programmer\u2019s Guide, should you need any additional background.</p>"},{"location":"RDi_Extension_Names/","title":"RDi Extension Names","text":""},{"location":"RDi_Extension_Names/#rdi-extension-names","title":"RDi Extension Names","text":"<p>As RDi is our preferred IDE, we recommend that the component extension name capability and associated action(s) function be used by all participants, in order to improve component granularity, consistency and productivity.</p> <p>The core intERPrise development team currently uses the following RDi extensions:</p> cpybk Copybook ddl Data Definition Language (SQL) bnd Binder Source clle CL program (usually *SRVPGM builder) rpgle RPG program rpglem RPG module sqlrpgle RPG with imbedded SQL program sqlrpglem RPG with imbedded SQL module lf DDS Logical File pnlgrp UIM panel group c C programs js JavaScript html HTML source css3 Cascading Style Sheets cmd Command source sql SQL (DML) source msgf IBM i Message file php PHP source json JSON file <p>We will soon schedule a recorded WebEx session, to demonstrate the definition and usage of the component extension and associated actions. Kindly check the https://www.i-nterprise.org/news---other-resources.html for the recording.</p>"},{"location":"RLA_and_SQL_result_set_processing/","title":"RLA and SQL result set processing","text":""},{"location":"RLA_and_SQL_result_set_processing/#rla-and-sql-result-set-processing","title":"RLA and SQL result set processing","text":"<p>The intERPrise architecture and database services constructs supports and leverages both RLA and SQL result set processing, in order to deliver maximum performance. This leaves developers of ANY consumptive service (be it any UI, a micro service, an API or any similar mechanism to facilitate human or system integration) to provide best performing solutions.</p> <p>Kindly review the provided code, to understand how this is implemented.</p>"},{"location":"Recommended_IDE_Release/","title":"Recommended IDE Release","text":""},{"location":"Recommended_IDE_Release/#recommended-ide-release","title":"Recommended IDE Release","text":"<p>The disparity between IDE and developer tools provided the committee with an enormous challenge, especially when considered in conjunction with \u201cfully free\u201d code considerations. A key consideration here is the developer tools primarily in use in the potential adopter installations.</p> <p>It is therefore important that all participants acknowledge that even though IBM no longer actively maintain ADTS (Application Development Tools on IBM i, such as SEU, PDM, etc.), it remains the primary developer tool in use on IBM i, especially in the SMB installed base.</p> <p>We strongly advise the adoption of RDi as the primary IDE, due to dramatic functionality improvements above ADTS, as well as significant improvement in developer productivity. This IDE will pay for itself in quick time, based on productivity improvements.</p> <p>Fully free (RPG) code can only be maintained with RDi version 9.5 and later.</p> <p>As a result of the reality that most SMB installations are using ADTS and based on our experience that a small percentage of installations that do use RDi are currently on RDi 9.5 or 9.6, ALL delivered code (until the latest releases of RDi become more freely available) MUST be usable and editable with ADTS and lower RDi releases than RDi 9.5.</p> <p>If RDi 9.5 or 9.6 becomes more freely available from a cost perspective, it will be our preferred IDE. Until then, the code published in intERPrise must be editable, with FULL syntax checking, with both ADTS and earlier releases of RDi and WDSC. Not following this approach, means that we will exclude the bulk of the potential adopters, which does not make any commercial and other sense.</p> <p>Additional to this, Mihael Schmidt has thankfully kindly agreed to make his MiWorkplace IDE available to developers that prefer a modern IDE, but cannot afford RDi. This IDE can be downloaded from https://miworkplace.com/index.php?content=download. Please read and follow the instructions on the website?</p>"},{"location":"Security_Implementation/","title":"Security Implementation","text":""},{"location":"Security_Implementation/#security-implementation","title":"Security Implementation","text":"<p>Due to the inherent security capabilities of IBM i and DB2 for i, intERPrise implements and leverages the native capabilities, to deliver an implementation we believe exemplifies how data can be secured. This is implemented at the lowest possible level within the operating system in each instance and consistent with the data centric approach.</p> <p>This ensures for instance that even QSECOFR cannot inject ANY database records into the database, except through the published interfaces.</p>"},{"location":"Source_Files/","title":"Source Files","text":""},{"location":"Source_Files/#source-files","title":"Source Files","text":"<p>The following source files are distributed with the distro, with ALL source in IRPSRC:</p> SRCCPY intERPrise Source copy books. SRCDB2 intERPrise DB2 components \u2013 all DDL and DDS-defined database components. SRCENT intERPrise Source for all non-database enterprise wide objects. SRCSRV intERPrise Source of all general/generic services SRCBLD intERPrise Build Components"},{"location":"Source_Repository_and_location_of_source_files/","title":"Source Repository and location of source files","text":""},{"location":"Source_Repository_and_location_of_source_files/#source-repository-and-location-of-source-files","title":"Source Repository and location of source files","text":"<p>We acknowledge that this decision will likely be a contentious one, as it seems to be a very emotive debate. Underpinning this decision, is the issue of the resulting object names, with specific reference to the QSYS.LIB file system and the IFS, and where the bulk of SMB developers find themselves. This consideration goes hand in hand with the consideration of who will likely adopt and use the solution.</p> <p>As a result, being heavily influenced by the object names and the potential users, all published source code will be structured to leverage the QSYS.LIB file system, which most developers are intimately familiar with. It is only the young generation that will need guidance in understanding this structure. It is however so simple and logical, that it should take a short while for young developers to understand the significance and beautiful simplicity of source code in the QSYS.LIB file system, where the true power of IBM i are demonstrated.</p> <p>Kindly study the section Source Files for a detailed list of published source files.</p>"},{"location":"Standard_Code_templates/","title":"Standard Code templates","text":""},{"location":"Standard_Code_templates/#standard-code-templates","title":"Standard Code Templates","text":"<p>All provided code in the database and JSON payload layer uses standard code templates, which will also be published at the time when the product will ship as GA.</p> <p>Additionally we are committed to work with participating developers, in providing standardized code templates for all general functions and will publish these as part of the base product, as soon as formally approved by the committee.</p>"},{"location":"Standardized_Error_Handling/","title":"Standardized Error Handling","text":""},{"location":"Standardized_Error_Handling/#standardized-error-handling","title":"Standardized Error Handling","text":"<p>All software error handling must use the provided message files and standardized error handling services. No deviation from this can be accepted, as the database and operating system are the originating source for any software errors or failures.</p> <p>If the provided error handling services do not cater for a specific condition, kindly contact management@i-nterprise.org with descriptive details of the limitation. A master enhancement will be provided, if it is indeed a limitation.</p>"},{"location":"Suggested_maximum_number_of_elements_components/","title":"Suggested maximum number of elements components","text":""},{"location":"Suggested_maximum_number_of_elements_components/#suggested-maximum-number-of-elementscomponents","title":"Suggested maximum number of elements/components","text":"<p>The primary consideration at all times should be maintainability of the produced code. We enforce a HARD limit of maximum 36 modules (enforced by the naming convention) per *SRVPGM and suggest that the number of procedures/functions per module should be limited to approximately 50 or as close to that as is practical, to facilitate manageability.</p>"},{"location":"Supported_Operating_System_Releases/","title":"Supported Operating System Releases","text":""},{"location":"Supported_Operating_System_Releases/#supported-operating-system-releases","title":"Supported Operating System Releases","text":"<p>The intERPrise solution is intended for IBM i release 7.2 (available since May 2, 2014) and IBM i release 7.3 (available since April 15, 2016). It is possible to install and compile for earlier releases of the operating system with quite a bit of manual intervention and potentially changing some code, although we STRONGLY advise against it.</p> <p>Companies should rather use this opportunity to get current on the operating system release and to adopt modern software engineering development practices.</p>"},{"location":"Supported_programming_languages/","title":"Supported programming languages","text":""},{"location":"Supported_programming_languages/#supported-programming-languages","title":"Supported programming languages","text":"<p>This entire initiative is dedicated to all the languages that forms part of the ILE programming model on IBM i: RPG, COBOL, C, C++ and CL for the back-end code. Standard JSON payloads will be rendered for ANY front-end \u201cconsumption\u201d.</p> <p>HTML5 and CSS3 combined with JavaScript or ANY language or environment that can \u201cconsume\u201d or integrate with JSON, will be the preferred mechanism for delivering interfaces and integration to other systems/users/API\u2019s.</p>"},{"location":"Target_Audience/","title":"Target Audience","text":""},{"location":"Target_Audience/#target-audience","title":"Target Audience","text":"<p>The intERPrise open source project has two distinct target audiences in mind, which are essentially worlds apart in terms of software engineering practices. As a result, the biggest challenge this initiative is confronted with, is to provide a mechanism or an approach that will facilitate collaboration and skills transfer on both sides of the audience spectrum.</p> <p>It is therefore of paramount importance that this initiative successfully straddles the chasm between the \u201cconsumers\u201d and contributing developers, successfully engaging, collaborating and implementing intERPrise architectural constructs and conventions.</p>"},{"location":"Target_Audience/#consumers-of-interprise","title":"Consumers of intERPrise","text":"<p>From a \u201cconsumer\u201d perspective, the ideal candidate client installation and developers are entities that can best be categorized as genuine SMB (https://www.gartner.com/it-glossary/smbs-small-and-midsize-businesses or https://whatis.techtarget.com/definition/SMB-small-and-medium-sized-business-or-small-and-midsized-business) installations, which remains a significant percentage of all IBM i (and predecessor systems) installations globally. It is an installation with usually less than five developers, often one to two developers and sometimes none (engaging with contract developers when the need arise).</p> <p>For these installations, their application often defines their business, and the business defines the application, having gradually evolved and matured as the company matured.</p> <p>Even though the application is critical to the existence of the business, there is continuous pressure on available funds, as most small and medium enterprises experience, with many competing considerations. Usually SMB investments will go towards core business infrastructure investments that have an immediate ROI (read sales and profit) and seldom to perceived \u201csupport functions\u201d like applications and systems.</p> <p>One of the secondary objectives of this initiative is to inform and demonstrate to SMB executives that their applications CAN (and SHOULD) have a DIRECT positive impact on their bottom line. It should also serve as catalyst to genuinely modernize their entire IBM i software asset portfolio.</p> <p>It is important to acknowledge the tremendous contribution these developers have made to the success of the platform and their employers. Additionally, it should also be acknowledged how much they achieve keeping the \u201clights on\u201d and their applications functioning, delivering this under exceptionally trying conditions.</p>"},{"location":"Target_Audience/#contributing-developers-to-interprise","title":"Contributing Developers to intERPrise","text":"<p>Most of the early contributors are software engineers who enjoy coding for a living/hobby and continuously testing the boundaries of software engineering approaches. They are most often early adopters of new tools, languages and approaches and always seek to hone and improve their skill. As such, pointer based processing, API\u2019s, software architecture, leveraging ILE, SQL and new IDE\u2019s are second nature to them. They will usually be comfortable developing in several languages and also comfortable with many computing platforms.</p> <p>Most of these developers will enjoy the perceived \u201cfreedom\u201d of descriptive (read long) program names and flexible file schemes for storing their source, using folder structures to keep components logically grouped. The complexity of continuously mapping between actual object names and the originating source, especially where you are managing potentially hundreds or thousands of objects in a production environment is seemingly not a impediment for them.</p> <p>This issue however highlights the challenge of bridging the gap between two completely different audiences, with entirely different coding objectives.</p> <p>As a result of the preceding background, it is important for the contributing developers to acknowledge that the published standards and conventions serve as mechanism to attempt to bridge this divide. It does not make sense to develop something, if it won\u2019t be adopted and used by the installed base.</p> <p>This infers that compromises will have to be found between the initial contributors and the potential adopters, with the primary consideration on the adopters, not developers, as this audience will determine the success or failure of this initiative.</p> <p>We subscribe to the KISS principle, keeping names and conventions clean, uncluttered and clear. It is of specific importance to acknowledge that even though some of the conventions may seem antiquated, it is not. The conventions adopted here, are adopted because they work consistently, reliably, simply and clearly.</p> <p>Just because some concepts may seem old, does not mean it is. The conventions and standards adopted are all brand new, even though some of them may seem old, because it is based on principles that has served the platform exceptionally well for 35+ years.</p>"},{"location":"Unacceptable_coding_constructs/","title":"Unacceptable coding constructs","text":""},{"location":"Unacceptable_coding_constructs/#unacceptable-coding-constructs","title":"Unacceptable coding constructs","text":"<ul> <li>Maximum of 3 nested IF statements, in order to remain clear and concise.</li> <li>No use of ELSEIF</li> <li>Proper indentation, following the provided code as example, to improve readability.</li> </ul> <p>Tommy Atkins (https://www.linkedin.com/in/tommyatkins/) will \u201cown\u201d and manage this section for the foreseeable future. The committee will evolve this, as we receive and review code contributions.</p>"},{"location":"Use_and_leveraging_of_standard_IBM_i_objects_and_architecture/","title":"Use and leveraging of standard IBM i objects and architecture","text":""},{"location":"Use_and_leveraging_of_standard_IBM_i_objects_and_architecture/#use-and-leveraging-of-standard-ibm-i-objects-and-architecture","title":"Use and leveraging of standard IBM i objects and architecture","text":"<p>It is of utmost importance that the inherent capabilities of IBM i and DB2 for i be exploited as far as possible, as this is where the platform and architecture shines. Of specific relevance is the tight integration between the operating system, DB2 and ILE, whilst establishing and implementing \u201cseparation\u201d between the database and the HLL used.</p> <p>The leveraging standard IBM i workmanagement, *USRSPC, *USRIDX, *MSGF, pointer based integration, etc. are of critical importance.</p>"},{"location":"Use_of_Adsero_Optima/","title":"Use of Adsero Optima","text":""},{"location":"Use_of_Adsero_Optima/#use-of-adsero-optimatm-ao-by-interprise-participating-developers","title":"Use of Adsero Optima\u2122 (AO) by intERPrise participating developers","text":"<p>One free copy of AO will be made available to the intERPrise Committee, on a machine of their choice, for as long as AO is involved in the delivery of intERPrise.</p>"},{"location":"Use_of_FULLY_FREE_format_RPG_source/","title":"Use of FULLY FREE format RPG source","text":""},{"location":"Use_of_FULLY_FREE_format_RPG_source/#use-of-fully-free-format-rpg-source","title":"Use of FULLY FREE format RPG source","text":"<p>As indicated earlier highlighting the conundrum around availability of tooling to maintain the provided source, the committee was forced to adopt a policy of implementing partially free code, against our wishes.</p> <p>This decision was taken in the best interest of primarily the SMB developer community (the most likely potential adopters), who has little choice in the tooling at their disposal. They are forced to use what their employer provides.</p> <p>As a result, we will adopt \u201cfree\u201d RPG code, as far as ADTS and RDi releases prior to RDi 9.5 syntax checker will recognize (kindly see Recommended IDE Release for more detail). The various AO provided database components will clearly delineate and demonstrate what the committee currently considers as best practices.</p>"},{"location":"Use_of_Source_code_Copy_Books/","title":"Use of Source code Copy Books","text":""},{"location":"Use_of_Source_code_Copy_Books/#use-of-source-code-copy-books","title":"Use of Source code \u201cCopy Books\u201d","text":"<p>Copy books are used extensively, limited to a single function/procedure per copybook, to achieve source code re-use, similar to how functions/procedures within modules are used in *SRVPGM\u2019s from an object perspective. It facilitates \u201csingle instance\u201d definition of code snippets and also enables a clean interface and integration between components.</p>"},{"location":"Use_of_libraries_schemas/","title":"Use of libraries (schemas)","text":""},{"location":"Use_of_libraries_schemas/#use-of-libraries-schemas","title":"Use of libraries (schemas)","text":"<p>The following libraries will be created during the automated build process, for storing the various categories of components:</p> IRPGPL intERPrise General Purpose Schema. IRPDB2 intERPrise all PF and LF database components. IRPDBC intERPrise all other database components \u2013 see Definition of database layer components that will be delivered by AO for a complete list. IRPENT intERPrise Enterprise (Controller) Layer of all other logic objects not part of database components. IRPSRC intERPrise ALL source files, regardless of function. IRPJRN intERPrise OPTIONAL journaling library for commitment control and HA. Usually, the IRPDB2 and IRPDBC libraries will represent/define the database layer of intERPrise. Users may optionally decide to keep the journal receivers separately. Normally the journals and journal receivers will be located in the IRPDB2 schema."},{"location":"Use_of_special_characters_in_source_and_object_naming/","title":"Use of special characters in source and object naming","text":""},{"location":"Use_of_special_characters_in_source_and_object_naming/#use-of-special-characters-in-source-and-object-naming","title":"Use of special characters in source and object naming","text":"<p>Due to the brevity of the naming scheme (10 character source member and object names), special characters are used to indicate SPECIFIC functions and use of components, to clearly highlight the specialized nature of that component.</p> <p>Kindly study the Database components naming conventions carefully for more detail.</p>"},{"location":"Use_of_special_characters_in_source_and_object_naming/#binder-source-member","title":"Binder Source Member","text":"<p>Every binder source member should have the \u2018@$\u2019 suffix, indicating that it is binder source, consistent with the database layer components.</p>"},{"location":"Use_of_special_characters_in_source_and_object_naming/#service-program-compiler","title":"Service Program Compiler","text":"<p>The service program compiler is a CLLE program containing a single statement which when executed will create the service program.</p> <p>This compiler is named for the service program with a suffix of \u2018@@\u2019, consistent with the database components. The service program *SRVPGM created by this compiler will have the same name as the compiler.</p>"},{"location":"Use_of_surrogate_keys_in_the_database/","title":"Use of surrogate keys in the database","text":""},{"location":"Use_of_surrogate_keys_in_the_database/#use-of-surrogate-keys-in-the-database","title":"Use of surrogate keys in the database","text":"<p>Although there are some situations where surrogate keys provide flexibility and some additional abstraction (we use it ourselves in very specific situations), we believe the use of surrogate keys usually suggest a lack of enough data analysis and correct implementation of proper normalization principles.</p> <p>We acknowledge that most SQL developers believe in using surrogate keys, although the approach flies in the face of Codd\u2019s database normalization rules, and in our opinion highlight limited analysis of the true requirement and provide a way to \u201cget away\u201d with limited upfront analysis.</p>"},{"location":"Validation_rules/","title":"Validation rules","text":""},{"location":"Validation_rules/#validation-rules","title":"Validation rules","text":"<p>The validations are stored and implemented from the Data Dictionary (DD aka Metadata repository) into the underlying code, by way of one of the following, with a \u201cweighting\u201d attached to the \u201cseniority\u201d of the validation rule within the Validation Rules Repository (VRR):</p> <ul> <li>the element (field) level globally as defined in DD,</li> <li>then an element (field) \\&lt;-&gt; file level defined within VRR and optionally overriding the global definition</li> <li>custom user developed validation procedure, optionally overriding any previous validations</li> </ul>"}]}